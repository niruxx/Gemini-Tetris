<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blocks | Retro Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --grid-color: #1f1f1f;
            --text-color: #ffffff;
            --accent-color: #00ffcc;
            --accent-secondary: #ff0055; /* Neon Pink */
            --ui-panel-bg: #111;
            --font-main: 'Press Start 2P', cursive;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        body.crt-enabled::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            z-index: 100;
            pointer-events: none;
        }

        /* Global Background */
        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background-color: rgba(0, 0, 0, 0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #bgCanvas.visible { opacity: 1; }

        /* Main Layout - 1v1 Style */
        .main-layout {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 40px;
            
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-origin: center center;
            
            z-index: 10;
            width: max-content;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            padding: 20px;
            border: 4px solid #333;
            border-radius: 4px;
            background-color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.1);
            position: relative;
        }

        /* Opponent View (1v1 Single Board) */
        .opponent-container {
            display: none; 
            flex-direction: column;
            align-items: center;
            padding: 20px;
            border: 4px solid #333;
            border-radius: 4px;
            background-color: #0a0a0a;
            opacity: 0.9;
            box-shadow: 0 0 30px rgba(255, 0, 85, 0.1);
        }
        
        .opponent-header {
            color: var(--accent-secondary);
            margin-bottom: 15px;
            font-size: 16px;
            text-shadow: 2px 2px #000;
        }

        canvas {
            background-color: #0a0a0a;
            display: block;
            border: 4px solid #222;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        #gameBoard { border-right: 4px solid #222; }

        .ui-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 180px; 
        }

        .stat-box {
            background-color: var(--ui-panel-bg);
            padding: 15px;
            border: 2px solid #333;
            border-radius: 0;
            text-align: center;
            box-shadow: 4px 4px 0px #000;
        }

        .stat-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 10px;
            text-transform: uppercase;
            line-height: 1.5;
        }

        .stat-value {
            font-size: 16px;
            color: var(--accent-color);
            text-shadow: 2px 2px 0px #000;
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 8px;
            color: #666;
            line-height: 2.0;
            text-align: left;
        }

        .key {
            display: inline-block;
            padding: 2px 4px;
            background: #333;
            color: #fff;
            font-size: 8px;
            border-bottom: 2px solid #111;
        }

        /* --- MENUS --- */
        .menu-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50; 
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.3s, transform 0.3s, visibility 0.3s;
            pointer-events: none;
        }
        .menu-layer.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
            pointer-events: auto;
        }

        .menu-window {
            background-color: rgba(10, 10, 10, 0.98);
            border: 4px solid var(--accent-color);
            padding: 40px;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 500px;
            position: relative;
            z-index: 55;
        }

        .debug-info {
            position: absolute;
            bottom: 15px;
            font-size: 8px;
            color: #444;
            width: 100%;
            text-align: center;
            z-index: 60;
            pointer-events: none;
        }

        h1 {
            font-size: 40px;
            margin: 0 0 50px 0;
            color: var(--accent-color);
            text-shadow: 4px 4px 0px #ff0055, 0 0 20px var(--accent-color);
            letter-spacing: -2px;
            text-align: center;
            line-height: 1.4;
        }

        .btn {
            padding: 15px 20px;
            font-size: 14px;
            background: #000;
            color: var(--accent-color);
            border: 4px solid var(--accent-color);
            cursor: pointer;
            font-family: var(--font-main);
            text-transform: uppercase;
            margin: 12px;
            min-width: 280px;
            transition: transform 0.1s;
            box-shadow: 6px 6px 0px #000000;
            position: relative;
        }
        .btn:hover {
            background: var(--accent-color);
            color: #000;
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0px #000, 0 0 15px var(--accent-color);
        }
        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }
        .btn:disabled {
            border-color: #444;
            color: #666;
            pointer-events: none;
            box-shadow: none;
        }

        .btn-secondary { border-color: var(--accent-secondary); color: var(--accent-secondary); }
        .btn-secondary:hover { background: var(--accent-secondary); color: #fff; box-shadow: 8px 8px 0px #000, 0 0 15px var(--accent-secondary); }

        .input-group { margin: 20px 0; display: flex; flex-direction: column; gap: 15px; align-items: center; }
        input { padding: 15px; font-family: var(--font-main); background: #222; border: 4px solid #555; color: #fff; font-size: 16px; text-align: center; width: 250px; outline: none; text-transform: uppercase; }
        input:focus { border-color: var(--accent-color); }
        .status-msg { margin-top: 25px; color: #aaa; font-size: 10px; min-height: 25px; }
        .room-code-display { font-size: 32px; color: #fff; background: #000; padding: 20px; border: 4px dashed #666; margin: 25px 0; letter-spacing: 4px; }
        
        .menu-header { font-size: 24px; color: #fff; margin-bottom: 30px; text-shadow: 3px 3px 0 var(--accent-secondary); text-align: center; width: 100%; border-bottom: 4px solid var(--accent-secondary); padding-bottom: 10px; }

        /* Slider */
        .slider { -webkit-appearance: none; width: 100%; max-width: 300px; height: 12px; background: #333; outline: none; border: 2px solid #555; margin: 15px 0; box-shadow: 4px 4px 0 #000; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; background: var(--accent-color); cursor: pointer; border: 2px solid #fff; box-shadow: 2px 2px 0 #000; }
    </style>
</head>
<body class="crt-enabled"> 

    <canvas id="bgCanvas"></canvas> 

    <div class="main-layout">
        <!-- Player 1 Container -->
        <div class="game-container">
            <canvas id="gameBoard" width="520" height="1040"></canvas>

            <div class="ui-panel">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Hold</div>
                    <canvas id="holdPiece" width="150" height="150"></canvas>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Level</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Next</div>
                    <canvas id="nextPiece" width="150" height="150"></canvas>
                </div>
                <div class="controls-hint">
                    <div><span class="key">W</span> <span class="key">↑</span> ROTATE</div>
                    <div><span class="key">A</span> <span class="key">←</span> LEFT</div>
                    <div><span class="key">S</span> <span class="key">↓</span> DROP</div>
                    <div><span class="key">D</span> <span class="key">→</span> RIGHT</div>
                    <div><span class="key">SPC</span> HARD DROP</div>
                    <div><span class="key">R</span> HOLD</div>
                    <div><span class="key">P</span> PAUSE</div>
                    <div><span class="key">ESC</span> MENU</div>
                </div>
            </div>

            <!-- Start Overlay -->
            <div id="overlay" class="menu-layer active">
                <h1 id="overlayTitle">NEON<br>BLOCKS</h1>
                <button id="resumeBtn" class="btn" style="display: none; border-color: #fff; color: #fff;">RESUME</button>
                <button id="startBtn" class="btn">SINGLE PLAYER</button>
                <button id="disconnectBtn" class="btn btn-secondary" style="display: none; border-color: #ff4444; color: #ff4444;">DISCONNECT</button>
                <button id="mpBtn" class="btn">MULTIPLAYER</button>
                <button id="optionsBtn" class="btn" style="border-color: #00ccff; color: #00ccff;">OPTIONS</button>
                <button id="aboutBtn" class="btn btn-secondary">ABOUT</button>
            </div>

            <!-- Options Menu -->
            <div id="optionsMenu" class="menu-layer">
                <div class="menu-window">
                    <div class="menu-header">OPTIONS</div>
                    <div class="stat-label" style="margin-bottom: 15px; font-size: 12px;">RESOLUTION</div>
                    <button class="btn res-btn" onclick="setResolution(720)">720p</button>
                    <button class="btn res-btn" onclick="setResolution(1080)">1080p</button>
                    <button class="btn res-btn" onclick="setResolution(1440)">1440p</button>
                    <div class="stat-label" style="margin-top: 30px; margin-bottom: 15px; font-size: 12px;">AUDIO & VISUALS</div>
                    <button id="musicToggleBtn" class="btn" style="border-color: #00ffcc; color: #00ffcc;">MUSIC: ON</button>
                    <button id="crtToggleBtn" class="btn" style="border-color: #00ffcc; color: #00ffcc;">CRT EFFECT: ON</button>
                    <button id="fsToggleBtn" class="btn" style="border-color: #00ffcc; color: #00ffcc;">FULLSCREEN: OFF</button>
                    <div class="stat-label" style="margin-top: 20px; font-size: 12px;">VOLUME <span id="volumeValue">50%</span></div>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50" class="slider">
                    <button id="optionsBackBtn" class="btn btn-secondary" style="margin-top: 30px;">BACK</button>
                </div>
            </div>

            <!-- About Menu -->
            <div id="aboutMenu" class="menu-layer">
                <div class="menu-window">
                    <div class="menu-header">SYSTEM INFO</div>
                    <div class="stat-box" style="width: 100%; margin-bottom: 15px;">
                        <div class="stat-label">App ID</div>
                        <div id="aboutAppId" style="font-size: 10px; word-break: break-all; color: #fff; line-height: 1.5;">Loading...</div>
                    </div>
                    <div class="stat-box" style="width: 100%; margin-bottom: 15px;">
                        <div class="stat-label">User ID</div>
                        <div id="aboutUserId" style="font-size: 10px; word-break: break-all; color: #fff; line-height: 1.5;">Not Logged In</div>
                    </div>
                    <button id="aboutBackBtn" class="btn btn-secondary">BACK</button>
                </div>
            </div>

            <!-- Multiplayer Menu (1v1 Simple) -->
            <div id="mpMenu" class="menu-layer">
                <div class="menu-window">
                    <div class="menu-header">MULTIPLAYER</div>
                    
                    <div id="mpOptions">
                        <button id="hostBtn" class="btn">HOST GAME</button>
                        <div class="input-group">
                            <div class="stat-label" style="margin-bottom: 0;">OR JOIN GAME</div>
                            <input type="text" id="joinCodeInput" placeholder="CODE" maxlength="6">
                            <button id="joinBtn" class="btn">JOIN</button>
                        </div>
                        <button id="backBtn" class="btn btn-secondary">BACK</button>
                    </div>

                    <div id="mpLobby" style="display:none; text-align: center; width: 100%;">
                        <div class="stat-label">ROOM CODE</div>
                        <div id="roomCodeDisplay" class="room-code-display">...</div>
                        <div class="status-msg" id="lobbyStatus">CONNECTING...</div>
                        <button id="cancelHostBtn" class="btn btn-secondary" style="margin-top: 20px;">CANCEL</button>
                    </div>
                    
                    <div class="status-msg" id="mpStatus"></div>
                </div>
            </div>
            
            <div class="debug-info" id="debugInfo">Initializing System...</div>
        </div>

        <!-- Opponent View (1v1 Single Board) -->
        <div class="opponent-container" id="opponentContainer">
            <div class="opponent-header">OPPONENT</div>
            <canvas id="opponentBoard" width="520" height="1040"></canvas>
            <div class="stat-box" style="margin-top: 15px; width: 100%; box-sizing: border-box;">
                <div class="stat-label">ENEMY SCORE</div>
                <div class="stat-value" id="oppScore" style="color: var(--opponent-color)">0</div>
            </div>
        </div>
    </div>

    <!-- Modules for Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'neon-blocks';

        let currentUser = null;
        // NOTE: Reverted to simple Account ID binding. Requires separate browsers/profiles to test MP.
        let currentGameId = null;
        let isHost = false;
        
        let gameSessionUnsubscribe = null;
        let opponentUnsubscribe = null;

        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };
        initAuth();
        
        const startBtn = document.getElementById('startBtn');
        const mpBtn = document.getElementById('mpBtn');
        const debugInfo = document.getElementById('debugInfo');
        startBtn.disabled = true; mpBtn.disabled = true; startBtn.innerText = "LOADING..."; mpBtn.style.opacity = "0.5";

        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            if (user) {
                startBtn.disabled = false; mpBtn.disabled = false; startBtn.innerText = "SINGLE PLAYER"; mpBtn.style.opacity = "1";
                debugInfo.innerText = `APP: ${appId.substring(0,6)} | UID: ${user.uid.substring(0,6)}`;
            }
        });

        // --- CONFIG & STATE ---
        const FPS = 120; 
        const MIN_FRAME_TIME = 1000 / FPS;
        const COLS = 10; const ROWS = 20;
        let BLOCK_SIZE = 52; 
        
        const CANVAS = document.getElementById('gameBoard');
        const CTX = CANVAS.getContext('2d');
        const NEXT_CANVAS = document.getElementById('nextPiece');
        const NEXT_CTX = NEXT_CANVAS.getContext('2d');
        const HOLD_CANVAS = document.getElementById('holdPiece');
        const HOLD_CTX = HOLD_CANVAS.getContext('2d');
        
        const OPP_CANVAS = document.getElementById('opponentBoard');
        const OPP_CTX = OPP_CANVAS.getContext('2d');

        const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#808080'];
        const PIECES = [null, [[0,1,0],[1,1,1],[0,0,0]], [[0,2,0,0],[0,2,0,0],[0,2,0,0],[0,2,0,0]], [[0,3,3],[3,3,0],[0,0,0]], [[4,4,0],[0,4,4],[0,0,0]], [[0,0,5],[5,5,5],[0,0,0]], [[6,6],[6,6]], [[7,0,0],[7,7,7],[0,0,0]]];

        let grid = createGrid(COLS, ROWS);
        let player = { pos: {x: 0, y: 0}, matrix: null, score: 0, level: 1, lines: 0 };
        let nextPieceMatrix = null; let holdPieceMatrix = null; let canHold = true;
        let dropCounter = 0; let dropInterval = 1000;
        let lastSpeedIncreaseScore = 0; const SPEED_BUMP_THRESHOLD = 5000;
        
        let isPaused = false; let isGameOver = false; let gameRunning = false; 
        let isAnimating = false; let animationTimer = 0; let clearingRows = []; const ANIMATION_DURATION = 300;
        
        const keyState = { ArrowLeft: false, ArrowRight: false, KeyA: false, KeyD: false };
        const moveTimers = { KeyA: 0, KeyD: 0 };
        const DAS_DELAY = 160; const DAS_SPEED = 50;
        let gameLoopId = null; let lastFrameTime = 0;

        let isMultiplayer = false;
        let lastSyncTime = 0;
        let lastAttackTime = 0; 
        let lastReceivedAttackTime = 0; 
        let opponentState = { grid: createGrid(COLS, ROWS), score: 0, active: null };

        // --- AUDIO ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();
        let musicEnabled = true; let crtEnabled = true; let masterVolume = 0.5;
        let nextNoteTime = 0; let noteIndex = 0; let musicTimerID = null; let musicTempo = 145;
        const lookahead = 25.0; const scheduleAheadTime = 0.1;
        const MELODY = [
            {f: 659.25, d: 0.5}, {f: 0, d: 0.25}, {f: 659.25, d: 0.25}, {f: 493.88, d: 0.5}, {f: 523.25, d: 0.5},
            {f: 587.33, d: 0.5}, {f: 0, d: 0.25}, {f: 587.33, d: 0.25}, {f: 523.25, d: 0.5}, {f: 493.88, d: 0.5},
            {f: 440.00, d: 0.5}, {f: 0, d: 0.25}, {f: 440.00, d: 0.25}, {f: 523.25, d: 0.5}, {f: 659.25, d: 0.5},
            {f: 587.33, d: 0.5}, {f: 523.25, d: 0.5}, {f: 493.88, d: 0.75}, {f: 493.88, d: 0.25},
            {f: 523.25, d: 0.5}, {f: 587.33, d: 0.5}, {f: 659.25, d: 0.5}, {f: 523.25, d: 0.5},
            {f: 440.00, d: 0.5}, {f: 440.00, d: 0.5}, {f: 0, d: 1},
            {f: 587.33, d: 0.75}, {f: 698.46, d: 0.25}, {f: 880.00, d: 0.5}, {f: 0, d: 0.25}, {f: 880.00, d: 0.25},
            {f: 783.99, d: 0.5}, {f: 698.46, d: 0.5}, {f: 659.25, d: 0.75}, {f: 0, d: 0.25},
            {f: 523.25, d: 0.5}, {f: 659.25, d: 0.5}, {f: 587.33, d: 0.5}, {f: 0, d: 0.25}, {f: 587.33, d: 0.25},
            {f: 523.25, d: 0.5}, {f: 493.88, d: 0.5}, {f: 493.88, d: 0.5}, {f: 0, d: 0.5},
            {f: 523.25, d: 0.25}, {f: 587.33, d: 0.25}, {f: 659.25, d: 0.5},
            {f: 523.25, d: 0.5}, {f: 440.00, d: 0.5}, {f: 440.00, d: 0.5}, {f: 220.00, d: 0.5},
            {f: 440.00, d: 0.25}, {f: 880.00, d: 0.25}, {f: 440.00, d: 0.5}, {f: 0, d: 1}
        ];

        function playLineClear() { if(!musicEnabled) return; const now=audioCtx.currentTime;const osc=audioCtx.createOscillator();const gain=audioCtx.createGain();osc.type='square';osc.frequency.setValueAtTime(440,now);osc.frequency.linearRampToValueAtTime(880,now+0.1);const vol=0.1*masterVolume;gain.gain.setValueAtTime(vol,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.1);osc.connect(gain);gain.connect(audioCtx.destination);osc.start(now);osc.stop(now+0.1);}
        function playThump() { if(!musicEnabled) return; const osc=audioCtx.createOscillator();const gain=audioCtx.createGain();osc.type='square';osc.frequency.setValueAtTime(150,audioCtx.currentTime);osc.frequency.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+0.15);const vol=0.1*masterVolume;gain.gain.setValueAtTime(vol,audioCtx.currentTime);const endVol=Math.max(0.0001,0.001*masterVolume);gain.gain.exponentialRampToValueAtTime(endVol,audioCtx.currentTime+0.1);osc.connect(gain);gain.connect(audioCtx.destination);osc.start();osc.stop(audioCtx.currentTime+0.15);}
        function playTone(freq,d,t){if(!musicEnabled||freq<=0||masterVolume<=0)return;const osc=audioCtx.createOscillator();const gain=audioCtx.createGain();osc.type='square';osc.frequency.value=freq;osc.connect(gain);gain.connect(audioCtx.destination);const vol=0.05*masterVolume;gain.gain.setValueAtTime(vol,t);const endVol=Math.max(0.0001,0.01*masterVolume);gain.gain.exponentialRampToValueAtTime(endVol,t+d-0.05);osc.start(t);osc.stop(t+d);}
        function scheduler(){while(nextNoteTime<audioCtx.currentTime+scheduleAheadTime){const note=MELODY[noteIndex];const s=60.0/musicTempo;const d=note.d*s;playTone(note.f,d,nextNoteTime);nextNoteTime+=d;noteIndex++;if(noteIndex>=MELODY.length)noteIndex=0;}musicTimerID=setTimeout(scheduler,lookahead);}
        function startMusic(){if(!musicEnabled)return;if(audioCtx.state==='suspended')audioCtx.resume();if(musicTimerID)clearTimeout(musicTimerID);nextNoteTime=audioCtx.currentTime+0.1;noteIndex=0;scheduler();}
        function stopMusic(){if(musicTimerID)clearTimeout(musicTimerID);musicTimerID=null;}
        function toggleMusic(){musicEnabled=!musicEnabled;const btn=document.getElementById('musicToggleBtn');if(musicEnabled){btn.innerText="MUSIC: ON";btn.style.borderColor="#00ffcc";btn.style.color="#00ffcc";if(gameRunning&&!isPaused)startMusic();}else{btn.innerText="MUSIC: OFF";btn.style.borderColor="#666";btn.style.color="#666";stopMusic();}}
        function toggleCRT(){crtEnabled=!crtEnabled;const btn=document.getElementById('crtToggleBtn');if(crtEnabled){btn.innerText="CRT EFFECT: ON";btn.style.borderColor="#00ffcc";btn.style.color="#00ffcc";document.body.classList.add('crt-enabled');}else{btn.innerText="CRT EFFECT: OFF";btn.style.borderColor="#666";btn.style.color="#666";document.body.classList.remove('crt-enabled');}}
        function toggleFullscreen(){const btn=document.getElementById('fsToggleBtn');if(!document.fullscreenElement){document.documentElement.requestFullscreen().catch(e=>{console.error(e);});}else{if(document.exitFullscreen){document.exitFullscreen();}}}
        document.addEventListener('fullscreenchange',(e)=>{const btn=document.getElementById('fsToggleBtn');if(document.fullscreenElement){btn.innerText="FULLSCREEN: ON";btn.style.borderColor="#00ffcc";btn.style.color="#00ffcc";}else{btn.innerText="FULLSCREEN: OFF";btn.style.borderColor="#666";btn.style.color="#666";}resizeGame();});

        // Background Animation
        const BG_CANVAS = document.getElementById('bgCanvas'); const BG_CTX = BG_CANVAS.getContext('2d'); let bgAnimationId = null; let bgPieces = [];
        function initMenuBackground(){BG_CANVAS.width=window.innerWidth;BG_CANVAS.height=window.innerHeight;BG_CANVAS.classList.add('visible');bgPieces=[];for(let i=0;i<15;i++)spawnBgPiece(true);if(!bgAnimationId)animateMenuBackground();}
        function spawnBgPiece(randomY=false){const pieceIdx=(Math.random()*7|0)+1;const piece={matrix:PIECES[pieceIdx],x:Math.floor(Math.random()*(BG_CANVAS.width/BLOCK_SIZE)),y:randomY?Math.floor(Math.random()*(BG_CANVAS.height/BLOCK_SIZE)):-4,speed:0.05+Math.random()*0.1,lastMove:0};bgPieces.push(piece);}
        function animateMenuBackground(){BG_CTX.fillStyle='#000000';BG_CTX.fillRect(0,0,BG_CANVAS.width,BG_CANVAS.height);for(let i=bgPieces.length-1;i>=0;i--){let p=bgPieces[i];p.y+=p.speed;drawBgMatrix(p.matrix,p.x*BLOCK_SIZE,p.y*BLOCK_SIZE);if(p.y*BLOCK_SIZE>BG_CANVAS.height){bgPieces.splice(i,1);spawnBgPiece();}}bgAnimationId=requestAnimationFrame(animateMenuBackground);}
        function drawBgMatrix(m,sx,sy){m.forEach((r,y)=>{r.forEach((v,x)=>{if(v!==0){BG_CTX.fillStyle=COLORS[v];BG_CTX.globalAlpha=0.15;BG_CTX.fillRect(sx+x*BLOCK_SIZE,sy+y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);BG_CTX.strokeStyle='rgba(255,255,255,0.05)';BG_CTX.strokeRect(sx+x*BLOCK_SIZE,sy+y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);BG_CTX.globalAlpha=1.0;}});});}
        function stopMenuBackground(){BG_CANVAS.classList.remove('visible');setTimeout(()=>{if(bgAnimationId){cancelAnimationFrame(bgAnimationId);bgAnimationId=null;}},500);}

        // --- GAME LOGIC ---
        function createGrid(w, h) { const m = []; while (h--) m.push(new Array(w).fill(0)); return m; }
        function collide(arena, player) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) { return true; } } } return false; }
        function drawMatrix(matrix, offset, context, ghostMode=false) { matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { context.fillStyle = ghostMode ? '#666' : COLORS[value]; context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); context.fillStyle = ghostMode ? 'rgba(255,255,255,0.1)' : 'rgba(255, 255, 255, 0.2)'; context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, 3); context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, 3, BLOCK_SIZE); context.strokeStyle = 'rgba(0, 0, 0, 0.3)'; context.lineWidth = 2; context.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); } }); }); }

        function draw() {
            // Local Player
            CTX.fillStyle = '#000'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
            drawGridLines(CTX, CANVAS.width, CANVAS.height);
            drawMatrix(grid, {x: 0, y: 0}, CTX);
            if (isAnimating && clearingRows.length > 0) { CTX.fillStyle = `rgba(255, 255, 255, ${Math.sin(Date.now() / 20) * 0.5 + 0.5})`; clearingRows.forEach(y => CTX.fillRect(0, y * BLOCK_SIZE, CANVAS.width, BLOCK_SIZE)); }
            if (!isAnimating && !isGameOver) { drawMatrix(player.matrix, player.pos, CTX); const ghostPos = { ...player.pos }; while (!collide(grid, { matrix: player.matrix, pos: ghostPos })) ghostPos.y++; ghostPos.y--; CTX.globalAlpha = 0.2; drawMatrix(player.matrix, ghostPos, CTX); CTX.globalAlpha = 1.0; }

            // Opponent (Single)
            if (isMultiplayer) {
                OPP_CTX.fillStyle = '#050505'; OPP_CTX.fillRect(0, 0, OPP_CANVAS.width, OPP_CANVAS.height);
                drawGridLines(OPP_CTX, OPP_CANVAS.width, OPP_CANVAS.height);
                if (opponentState.grid) drawMatrix(opponentState.grid, {x: 0, y: 0}, OPP_CTX, true);
                if (opponentState.active) { OPP_CTX.globalAlpha = 0.6; drawMatrix(opponentState.active.matrix, opponentState.active.pos, OPP_CTX, true); OPP_CTX.globalAlpha = 1.0; }
            }

            drawPiecePreview(HOLD_CTX, holdPieceMatrix, HOLD_CANVAS);
            drawPiecePreview(NEXT_CTX, nextPieceMatrix, NEXT_CANVAS);
        }

        function drawGridLines(ctx, w, h) { ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; for(let i = 0; i <= COLS; i++) { ctx.beginPath(); ctx.moveTo(i * BLOCK_SIZE, 0); ctx.lineTo(i * BLOCK_SIZE, h); ctx.stroke(); } for(let i = 0; i <= ROWS; i++) { ctx.beginPath(); ctx.moveTo(0, i * BLOCK_SIZE); ctx.lineTo(w, i * BLOCK_SIZE); ctx.stroke(); } }
        function drawPiecePreview(ctx, m, c) { ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, c.width, c.height); if (m) { const ox = (4 - m[0].length) / 2; const oy = (4 - m.length) / 2; ctx.save(); ctx.scale(0.6, 0.6); drawMatrix(m, {x: ox + 0.5, y: oy + 0.5}, ctx); ctx.restore(); } }

        // --- MULTIPLAYER LOGIC (1v1 Reverted) ---
        const generateCode = () => Math.floor(100000 + Math.random() * 900000).toString();

        async function syncMultiplayerState(force = false) {
            if (!isMultiplayer || !currentUser || !currentGameId) return;
            const now = Date.now();
            if (!force && now - lastSyncTime < 50) return;
            try {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'gamestates', currentUser.uid), {
                    grid: JSON.stringify(grid), score: player.score, lastAttackTime: lastAttackTime,
                    active: { matrix: JSON.stringify(player.matrix), pos: player.pos }, timestamp: now
                });
                lastSyncTime = now;
            } catch (e) { console.error(e); }
        }

        async function hostGame() {
            if (!currentUser) return;
            document.getElementById('mpOptions').style.display = 'none';
            document.getElementById('mpLobby').style.display = 'block';
            document.getElementById('roomCodeDisplay').innerText = "LOADING...";
            const code = generateCode();
            const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', code);
            try {
                await setDoc(sessionRef, { host: currentUser.uid, code: code, status: 'waiting', timestamp: Date.now() });
                document.getElementById('roomCodeDisplay').innerText = code;
                document.getElementById('lobbyStatus').innerText = "WAITING FOR PLAYER...";
                currentGameId = code; isHost = true;
                gameSessionUnsubscribe = onSnapshot(sessionRef, (snap) => {
                    const data = snap.data();
                    if (data && data.guest) startMultiplayerGame(data.guest);
                });
            } catch (e) { console.error(e); document.getElementById('mpStatus').innerText = "Error: " + e.message; }
        }

        async function joinGame() {
            if (!currentUser) return;
            const code = document.getElementById('joinCodeInput').value.trim();
            if (code.length !== 6) { document.getElementById('mpStatus').innerText = "INVALID CODE"; return; }
            document.getElementById('mpStatus').innerText = "SEARCHING...";
            const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', code);
            try {
                const docSnap = await getDoc(sessionRef);
                if (!docSnap.exists()) { document.getElementById('mpStatus').innerText = "ROOM NOT FOUND"; return; }
                const data = docSnap.data();
                if (data.status !== 'waiting') { document.getElementById('mpStatus').innerText = "GAME IN PROGRESS"; return; }
                await setDoc(sessionRef, { ...data, guest: currentUser.uid, status: 'playing' });
                currentGameId = code; isHost = false;
                startMultiplayerGame(data.host);
            } catch (e) { console.error(e); document.getElementById('mpStatus').innerText = "Join Error: " + e.message; }
        }

        function startMultiplayerGame(opponentUid) {
            isMultiplayer = true;
            lastReceivedAttackTime = 0;
            if (gameSessionUnsubscribe) gameSessionUnsubscribe();
            hideAllMenus();
            document.getElementById('opponentContainer').style.display = 'flex';
            
            // Trigger resize to fit both boards
            resizeGame();
            
            const opponentStateRef = doc(db, 'artifacts', appId, 'public', 'data', 'gamestates', opponentUid);
            opponentUnsubscribe = onSnapshot(opponentStateRef, (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    if (data.grid) opponentState.grid = JSON.parse(data.grid);
                    opponentState.score = data.score || 0;
                    if (data.active) opponentState.active = { matrix: JSON.parse(data.active.matrix), pos: data.active.pos };
                    document.getElementById('oppScore').innerText = opponentState.score;
                    if (data.lastAttackTime && data.lastAttackTime > lastReceivedAttackTime) {
                        if (lastReceivedAttackTime !== 0) addGarbageRow();
                        lastReceivedAttackTime = data.lastAttackTime;
                    }
                    if (lastReceivedAttackTime === 0 && data.lastAttackTime) lastReceivedAttackTime = data.lastAttackTime;
                }
            });
            startGame();
        }

        // Standard Gameplay
        function merge(arena, player) { player.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { arena[y + player.pos.y][x + player.pos.x] = value; } }); }); syncMultiplayerState(true); }
        function rotate(matrix, dir) { for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse(); }
        function playerDrop() { player.pos.y++; if (collide(grid, player)) { player.pos.y--; merge(grid, player); const fullRows = []; grid.forEach((row, y) => { if (row.every(value => value !== 0)) fullRows.push(y); }); if (fullRows.length > 0) startLineClearAnimation(fullRows); else { playerReset(); updateScore(); } } dropCounter = 0; }
        function playerHardDrop() { while (!collide(grid, player)) player.pos.y++; player.pos.y--; merge(grid, player); playThump(); const fullRows = []; grid.forEach((row, y) => { if (row.every(value => value !== 0)) fullRows.push(y); }); if (fullRows.length > 0) startLineClearAnimation(fullRows); else { playerReset(); updateScore(); } dropCounter = 0; }
        function startLineClearAnimation(rows) { isAnimating = true; clearingRows = rows; animationTimer = 0; }
        function finalizeLineClear() { let rowCount = 0; clearingRows.sort((a, b) => a - b); for (let i = 0; i < clearingRows.length; i++) { const y = clearingRows[i]; const row = grid.splice(y, 1)[0].fill(0); grid.unshift(row); rowCount++; } if (rowCount > 0) { playLineClear(); const lineScores = [0, 40, 100, 300, 1200]; player.score += lineScores[rowCount] * player.level; player.lines += rowCount; player.level = Math.floor(player.lines / 10) + 1; if (rowCount >= 4 && isMultiplayer) { lastAttackTime = Date.now(); } } updateScore(); playerReset(); isAnimating = false; clearingRows = []; syncMultiplayerState(true); }
        function addGarbageRow() { grid.shift(); const row = new Array(COLS).fill(8); const hole = Math.floor(Math.random() * COLS); row[hole] = 0; grid.push(row); player.pos.y--; draw(); }
        function playerMove(dir) { player.pos.x += dir; if (collide(grid, player)) player.pos.x -= dir; }
        function playerRotate(dir) { const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir); while (collide(grid, player)) { player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; } } }
        function playerHold() { if (!canHold) return; if (!holdPieceMatrix) { holdPieceMatrix = player.matrix; playerReset(); } else { const temp = player.matrix; player.matrix = holdPieceMatrix; holdPieceMatrix = temp; player.pos.y = 0; player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0); } canHold = false; }
        function getRandomPiece() { const type = 'ILJOTSZ'[Math.floor(Math.random() * 7)]; let idx = 1; if(type === 'I') idx = 2; else if(type === 'S') idx = 3; else if(type === 'Z') idx = 4; else if(type === 'L') idx = 5; else if(type === 'O') idx = 6; else if(type === 'J') idx = 7; return PIECES[idx].map(row => [...row]); }
        function playerReset() { if (!nextPieceMatrix) nextPieceMatrix = getRandomPiece(); player.matrix = nextPieceMatrix; nextPieceMatrix = getRandomPiece(); player.pos.y = 0; player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0); canHold = true; if (collide(grid, player)) { isGameOver = true; document.getElementById('overlayTitle').innerText = "GAME OVER"; if (isMultiplayer) { document.getElementById('startBtn').style.display = 'none'; document.getElementById('mpBtn').style.display = 'none'; document.getElementById('resumeBtn').style.display = 'none'; document.getElementById('disconnectBtn').style.display = 'block'; } else { document.getElementById('startBtn').innerText = "RESTART"; document.getElementById('startBtn').style.display = 'block'; document.getElementById('mpBtn').style.display = 'block'; document.getElementById('disconnectBtn').style.display = 'none'; } showMenu('overlay'); initMenuBackground(); stopGameLoop(); } }
        function disconnectGame() { if (gameSessionUnsubscribe) gameSessionUnsubscribe(); if (opponentUnsubscribe) opponentUnsubscribe(); gameSessionUnsubscribe = null; opponentUnsubscribe = null; isMultiplayer = false; isHost = false; currentGameId = null; document.getElementById('opponentContainer').style.display = 'none'; document.getElementById('disconnectBtn').style.display = 'none'; document.getElementById('startBtn').style.display = 'block'; document.getElementById('startBtn').innerText = "SINGLE PLAYER"; document.getElementById('mpBtn').style.display = 'block'; document.getElementById('overlayTitle').innerHTML = "NEON<br>BLOCKS"; showMenu('overlay'); gameRunning = false; isGameOver = false; isPaused = false; initMenuBackground(); resizeGame(); }
        function updateScore() { document.getElementById('score').innerText = player.score; document.getElementById('level').innerText = player.level; if (player.score - lastSpeedIncreaseScore >= SPEED_BUMP_THRESHOLD) { lastSpeedIncreaseScore = Math.floor(player.score / SPEED_BUMP_THRESHOLD) * SPEED_BUMP_THRESHOLD; dropInterval = Math.max(50, dropInterval * 0.9); } if (isMultiplayer) syncMultiplayerState(true); }
        window.setResolution = function(height) { BLOCK_SIZE = height / ROWS; CANVAS.height = height; CANVAS.width = BLOCK_SIZE * COLS; OPP_CANVAS.height = height; OPP_CANVAS.width = BLOCK_SIZE * COLS; if (player.matrix) draw(); document.querySelectorAll('.res-btn').forEach(btn => { if(btn.innerText.includes(height)) btn.style.background = 'var(--accent-color)'; else btn.style.background = 'transparent'; }); if(typeof resizeGame === 'function') resizeGame(); }
        
        function update(dt) { if (isPaused || isGameOver) return; if (isAnimating) { animationTimer += dt; if (animationTimer >= ANIMATION_DURATION) finalizeLineClear(); draw(); return; } if (keyState.KeyA || keyState.ArrowLeft) { moveTimers.KeyA += dt; if (moveTimers.KeyA > DAS_DELAY) { moveTimers.KeyA -= DAS_SPEED; playerMove(-1); } } if (keyState.KeyD || keyState.ArrowRight) { moveTimers.KeyD += dt; if (moveTimers.KeyD > DAS_DELAY) { moveTimers.KeyD -= DAS_SPEED; playerMove(1); } } dropCounter += dt; if (dropCounter > dropInterval) playerDrop(); draw(); if (isMultiplayer) syncMultiplayerState(); }
        function startGame() { grid = createGrid(COLS, ROWS); player.score = 0; player.lines = 0; player.level = 1; lastSpeedIncreaseScore = 0; updateScore(); dropInterval = 1000; isGameOver = false; isPaused = false; isAnimating = false; gameRunning = true; keyState.KeyA = false; keyState.KeyD = false; keyState.ArrowLeft = false; keyState.ArrowRight = false; playerReset(); hideAllMenus(); document.getElementById('resumeBtn').style.display = "none"; document.getElementById('disconnectBtn').style.display = "none"; stopMenuBackground(); startMusic(); if (gameLoopId) cancelAnimationFrame(gameLoopId); lastFrameTime = performance.now(); gameLoopId = requestAnimationFrame(gameLoop); draw(); }
        function gameLoop(ts) { if (!gameRunning) return; const dt = ts - lastFrameTime; if (dt >= MIN_FRAME_TIME) { update(Math.min(dt, 100)); lastFrameTime = ts - (dt % MIN_FRAME_TIME); } if (!isGameOver) { gameLoopId = requestAnimationFrame(gameLoop); } }
        function stopGameLoop() { if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; stopMusic(); }
        function hideAllMenus() { document.querySelectorAll('.menu-layer').forEach(el => el.classList.remove('active')); }
        function showMenu(id) { hideAllMenus(); const el = document.getElementById(id); if (el) el.classList.add('active'); if (id === 'overlay') initMenuBackground(); }
        function toggleMenu() { const isMenuOpen = document.querySelector('.menu-layer.active'); if (isMenuOpen) { if (gameRunning) { hideAllMenus(); stopMenuBackground(); if (!isMultiplayer) isPaused = false; if(musicEnabled) startMusic(); } } else { if (gameRunning) { document.getElementById('resumeBtn').style.display = 'block'; document.getElementById('startBtn').innerText = "NEW GAME"; if (isMultiplayer) { document.getElementById('disconnectBtn').style.display = 'block'; document.getElementById('startBtn').style.display = 'none'; document.getElementById('mpBtn').style.display = 'none'; } else { document.getElementById('disconnectBtn').style.display = 'none'; document.getElementById('startBtn').style.display = 'block'; document.getElementById('mpBtn').style.display = 'block'; } } else { document.getElementById('resumeBtn').style.display = 'none'; document.getElementById('startBtn').innerText = "SINGLE PLAYER"; document.getElementById('disconnectBtn').style.display = 'none'; } showMenu('overlay'); initMenuBackground(); if (!isMultiplayer) isPaused = true; stopMusic(); } }
        
        initMenuBackground(); showMenu('overlay');
        document.addEventListener('keydown', e => { if (e.target.tagName === 'INPUT') return; if (e.code === 'Escape') { const activeMenu = document.querySelector('.menu-layer.active'); if (activeMenu && activeMenu.id !== 'overlay') { showMenu('overlay'); return; } toggleMenu(); return; } if (document.querySelector('.menu-layer.active')) return; if (isGameOver) return; if (e.code === 'KeyP') { isPaused = !isPaused; if (isPaused) { CTX.fillStyle = 'rgba(0,0,0,0.5)'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height); CTX.fillStyle = '#fff'; CTX.font = '40px "Press Start 2P"'; CTX.textAlign = 'center'; CTX.fillText("PAUSED", CANVAS.width/2, CANVAS.height/2); } } if (isPaused || isAnimating) return; if ((e.code === 'KeyA' || e.code === 'ArrowLeft') && !(keyState.KeyA || keyState.ArrowLeft)) { if (e.code === 'KeyA') keyState.KeyA = true; if (e.code === 'ArrowLeft') keyState.ArrowLeft = true; moveTimers.KeyA = -DAS_DELAY; playerMove(-1); draw(); } if ((e.code === 'KeyD' || e.code === 'ArrowRight') && !(keyState.KeyD || keyState.ArrowRight)) { if (e.code === 'KeyD') keyState.KeyD = true; if (e.code === 'ArrowRight') keyState.ArrowRight = true; moveTimers.KeyD = -DAS_DELAY; playerMove(1); draw(); } switch(e.code) { case 'KeyS': case 'ArrowDown': playerDrop(); draw(); break; case 'KeyW': case 'ArrowUp': playerRotate(1); draw(); break; case 'Space': playerHardDrop(); draw(); break; case 'KeyR': playerHold(); draw(); break; } });
        document.addEventListener('keyup', e => { if (e.code === 'KeyA') keyState.KeyA = false; if (e.code === 'KeyD') keyState.KeyD = false; if (e.code === 'ArrowLeft') keyState.ArrowLeft = false; if (e.code === 'ArrowRight') keyState.ArrowRight = false; });
        window.addEventListener('keydown', function(e) { if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1 && e.target.tagName !== 'INPUT') { e.preventDefault(); } }, false);

        document.getElementById('resumeBtn').addEventListener('click', toggleMenu);
        document.getElementById('disconnectBtn').addEventListener('click', disconnectGame);
        document.getElementById('startBtn').addEventListener('click', () => { isMultiplayer = false; document.getElementById('opponentContainer').style.display = 'none'; startGame(); });
        document.getElementById('optionsBtn').addEventListener('click', () => showMenu('optionsMenu'));
        document.getElementById('optionsBackBtn').addEventListener('click', () => showMenu('overlay'));
        document.getElementById('musicToggleBtn').addEventListener('click', toggleMusic);
        document.getElementById('crtToggleBtn').addEventListener('click', toggleCRT);
        document.getElementById('fsToggleBtn').addEventListener('click', toggleFullscreen);
        document.getElementById('volumeSlider').addEventListener('input', (e) => { masterVolume = e.target.value / 100; document.getElementById('volumeValue').innerText = e.target.value + "%"; });
        document.getElementById('mpBtn').addEventListener('click', () => { showMenu('mpMenu'); document.getElementById('mpOptions').style.display = 'block'; document.getElementById('mpLobby').style.display = 'none'; document.getElementById('mpStatus').innerText = ""; });
        document.getElementById('aboutBtn').addEventListener('click', () => { showMenu('aboutMenu'); document.getElementById('aboutAppId').innerText = appId; if (currentUser) document.getElementById('aboutUserId').innerText = currentUser.uid; });
        document.getElementById('aboutBackBtn').addEventListener('click', () => showMenu('overlay'));
        document.getElementById('backBtn').addEventListener('click', () => showMenu('overlay'));
        document.getElementById('hostBtn').addEventListener('click', hostGame);
        document.getElementById('joinBtn').addEventListener('click', joinGame);
        document.getElementById('cancelHostBtn').addEventListener('click', () => { if (gameSessionUnsubscribe) gameSessionUnsubscribe(); document.getElementById('mpLobby').style.display = 'none'; document.getElementById('mpOptions').style.display = 'block'; });

        function resizeGame() { const layout = document.querySelector('.main-layout'); if (!layout) return; const padding = 40; const availableWidth = window.innerWidth - padding; const availableHeight = window.innerHeight - padding; let baseWidth = 800; if (isMultiplayer) baseWidth = 1600; const baseHeight = 1100; const scaleX = availableWidth / baseWidth; const scaleY = availableHeight / baseHeight; const scale = Math.min(scaleX, scaleY); layout.style.transform = `translate(-50%, -50%) scale(${scale})`; }
        window.addEventListener('resize', resizeGame); resizeGame(); setTimeout(resizeGame, 500);
    </script>
</body>
</html>