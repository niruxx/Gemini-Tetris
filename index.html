<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blocks | 4-Player</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --grid-color: #1f1f1f;
            --text-color: #ffffff;
            --accent-color: #00ffcc;
            --accent-secondary: #ff0055; /* Neon Pink */
            --ui-panel-bg: #111;
            --font-main: 'Press Start 2P', cursive;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        body.crt-enabled::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            z-index: 100;
            pointer-events: none;
        }

        /* Main layout */
        .main-layout {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 30px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-origin: center center;
            z-index: 5;
            width: max-content;
        }

        .game-wrapper {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            padding: 20px;
            border: 4px solid #333;
            border-radius: 4px;
            background-color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.1);
            position: relative;
        }

        /* OPPONENT GRID (Dynamic) */
        .opponents-wrapper {
            display: none; /* Hidden until MP starts */
            flex-direction: column;
            gap: 15px;
        }

        .opponent-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border: 4px solid #333;
            border-radius: 4px;
            background-color: #0a0a0a;
            opacity: 0.9;
            position: relative;
        }

        .opponent-header {
            color: var(--accent-secondary);
            margin-bottom: 5px;
            font-size: 10px;
            text-shadow: 1px 1px #000;
        }

        canvas {
            background-color: #0a0a0a;
            display: block;
            border: 4px solid #222;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        #gameBoard {
            border-right: 4px solid #222;
        }

        /* Smaller canvases for opponents */
        .opp-canvas {
            border: 2px solid #222;
            width: 173px; /* Scale down 1/3 or 1/2 depending on space. 520/3 = ~173 */
            height: 346px; 
        }

        .ui-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 180px; 
        }

        .stat-box {
            background-color: var(--ui-panel-bg);
            padding: 15px;
            border: 2px solid #333;
            border-radius: 0;
            text-align: center;
            box-shadow: 4px 4px 0px #000;
        }

        .stat-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 10px;
            text-transform: uppercase;
            line-height: 1.5;
        }

        .stat-value {
            font-size: 16px;
            color: var(--accent-color);
            text-shadow: 2px 2px 0px #000;
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 8px;
            color: #666;
            line-height: 2.0;
            text-align: left;
        }

        .key {
            display: inline-block;
            padding: 2px 4px;
            background: #333;
            color: #fff;
            font-size: 8px;
            border-bottom: 2px solid #111;
        }

        /* --- MENU LAYERS --- */
        .menu-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            transition: opacity 0.3s, transform 0.3s, visibility 0.3s;
            pointer-events: none;
        }

        .menu-layer.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
            pointer-events: auto;
        }

        .menu-window {
            background-color: rgba(10, 10, 10, 0.95);
            border: 4px solid var(--accent-color);
            padding: 40px;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 500px;
            position: relative;
            z-index: 30;
        }
        
        #bgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            background-color: rgba(0, 0, 0, 0.8); 
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #bgCanvas.visible {
            opacity: 1;
        }

        .debug-info {
            position: absolute;
            bottom: 15px;
            font-size: 8px;
            color: #444;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
        }

        h1 {
            font-size: 40px;
            margin: 0 0 50px 0;
            color: var(--accent-color);
            text-shadow: 4px 4px 0px #ff0055, 0 0 20px var(--accent-color);
            letter-spacing: -2px;
            text-align: center;
            line-height: 1.4;
        }

        .btn {
            padding: 15px 20px;
            font-size: 14px;
            background: #000;
            color: var(--accent-color);
            border: 4px solid var(--accent-color);
            cursor: pointer;
            font-family: var(--font-main);
            text-transform: uppercase;
            margin: 12px;
            min-width: 280px;
            transition: transform 0.1s, background-color 0.1s, box-shadow 0.1s;
            box-shadow: 6px 6px 0px #000000;
            position: relative;
        }

        .btn:hover {
            background: var(--accent-color);
            color: #000;
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0px #000, 0 0 15px var(--accent-color);
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }
        
        .btn:disabled {
            border-color: #444;
            color: #666;
            pointer-events: none;
            box-shadow: none;
        }

        .btn-secondary {
            border-color: var(--accent-secondary);
            color: var(--accent-secondary);
        }
        .btn-secondary:hover {
            background: var(--accent-secondary);
            color: #fff;
            box-shadow: 8px 8px 0px #000, 0 0 15px var(--accent-secondary);
        }

        .input-group {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        input {
            padding: 15px;
            font-family: var(--font-main);
            background: #222;
            border: 4px solid #555;
            color: #fff;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            width: 250px;
            outline: none;
        }
        input:focus {
            border-color: var(--accent-color);
        }

        .status-msg {
            margin-top: 25px;
            color: #aaa;
            font-size: 10px;
            min-height: 25px;
        }

        .room-code-display {
            font-size: 32px;
            color: #fff;
            background: #000;
            padding: 20px;
            border: 4px dashed #666;
            margin: 25px 0;
            letter-spacing: 4px;
            text-shadow: 2px 2px 0 #333;
        }

        /* Lobby Player List */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            margin: 20px 0;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #1a1a1a;
            border: 2px solid #333;
            font-size: 12px;
        }
        
        .player-item.ready {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }
        
        .player-item.not-ready {
            border-color: #444;
            color: #666;
        }

        .status-pill {
            font-size: 8px;
            padding: 4px 8px;
            background: #333;
            color: #fff;
        }
        .player-item.ready .status-pill { background: var(--accent-color); color: #000; }

        /* Menu Headers */
        .menu-header {
            font-size: 24px;
            color: #fff;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 var(--accent-secondary);
            text-align: center;
            width: 100%;
            border-bottom: 4px solid var(--accent-secondary);
            padding-bottom: 10px;
        }

        /* Slider Styling */
        .slider {
            -webkit-appearance: none;
            width: 100%;
            max-width: 300px;
            height: 12px;
            background: #333;
            outline: none;
            border: 2px solid #555;
            margin: 15px 0;
            box-shadow: 4px 4px 0 #000;
        }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; background: var(--accent-color); cursor: pointer; border: 2px solid #fff; box-shadow: 2px 2px 0 #000; }
        .slider::-moz-range-thumb { width: 24px; height: 24px; background: var(--accent-color); cursor: pointer; border: 2px solid #fff; box-shadow: 2px 2px 0 #000; }

        /* --- CHAT BOX STYLES --- */
        .chat-container {
            display: none; /* Hidden by default */
            width: 300px; /* Fixed sidebar width */
            height: 1088px; /* Fixed height to match Game Container */
            background: #0a0a0a;
            border: 4px solid #333;
            border-radius: 4px;
            margin-top: 0; 
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .chat-header {
            background: #111;
            color: #888;
            padding: 15px;
            text-align: center;
            font-size: 12px;
            border-bottom: 4px solid #333;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .chat-messages {
            flex: 1; /* Grow to fill height */
            overflow-y: auto;
            padding: 15px;
            border-bottom: 4px solid #333;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 10px;
            background: #000;
        }
        
        /* Custom Scrollbar for chat */
        .chat-messages::-webkit-scrollbar { width: 8px; }
        .chat-messages::-webkit-scrollbar-track { background: #111; }
        .chat-messages::-webkit-scrollbar-thumb { background: #444; }

        .chat-msg {
            word-break: break-word;
            line-height: 1.6;
            font-family: var(--font-main);
        }
        
        /* Player 1 (Host) = Blue/Cyan */
        .chat-msg.p1 .sender { color: var(--accent-color); text-shadow: 0 0 5px rgba(0, 255, 204, 0.5); }
        .chat-msg.p2 .sender { color: var(--accent-secondary); text-shadow: 0 0 5px rgba(255, 0, 85, 0.5); }
        .chat-msg.p3 .sender { color: #ffcc00; text-shadow: 0 0 5px rgba(255, 204, 0, 0.5); }
        .chat-msg.p4 .sender { color: #cc00ff; text-shadow: 0 0 5px rgba(204, 0, 255, 0.5); }
        
        .chat-msg .sender { font-weight: bold; margin-right: 5px; display: inline-block; }
        .chat-msg .content { color: #ddd; }

        .chat-input-area {
            display: flex;
            padding: 0;
            background: #111;
            height: 60px;
        }

        #chatInput {
            flex: 1;
            background: #000;
            border: none;
            padding: 15px;
            color: #fff;
            font-family: var(--font-main);
            font-size: 12px;
            text-transform: none; /* Allow normal casing */
            text-align: left;
            width: auto;
            user-select: text; /* Allow selection/typing */
        }
        #chatInput:focus {
            outline: 4px solid var(--accent-color);
            outline-offset: -4px;
        }

        #chatSendBtn {
            background: #222;
            color: #fff;
            border: none;
            border-left: 4px solid #333;
            padding: 0 20px;
            font-family: var(--font-main);
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #chatSendBtn:hover {
            background: var(--accent-color);
            color: #000;
        }

        @media (max-width: 1200px) {
            .main-layout {
                /* Scale removed, relying on JS auto-scale now */
            }
        }
    </style>
</head>
<body class="crt-enabled"> 

    <div class="main-layout">
        <canvas id="bgCanvas"></canvas> 

        <div class="game-wrapper">
            <div class="game-container">
                <canvas id="gameBoard" width="520" height="1040"></canvas>

                <!-- Side UI -->
                <div class="ui-panel">
                    <div class="stat-box">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="score">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Hold</div>
                        <canvas id="holdPiece" width="150" height="150"></canvas>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Level</div>
                        <div class="stat-value" id="level">1</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Next</div>
                        <canvas id="nextPiece" width="150" height="150"></canvas>
                    </div>
                    <div class="controls-hint">
                        <div><span class="key">W</span> <span class="key">↑</span> ROTATE</div>
                        <div><span class="key">A</span> <span class="key">←</span> LEFT</div>
                        <div><span class="key">S</span> <span class="key">↓</span> DROP</div>
                        <div><span class="key">D</span> <span class="key">→</span> RIGHT</div>
                        <div><span class="key">SPC</span> HARD DROP</div>
                        <div><span class="key">R</span> HOLD</div>
                        <div><span class="key">P</span> PAUSE</div>
                        <div><span class="key">ESC</span> MENU</div>
                    </div>
                </div>

                <!-- Start Overlay -->
                <div id="overlay" class="menu-layer active">
                    <h1 id="overlayTitle">NEON<br>BLOCKS</h1>
                    <button id="resumeBtn" class="btn" style="display: none; border-color: #fff; color: #fff;">RESUME</button>
                    <button id="startBtn" class="btn">SINGLE PLAYER</button>
                    <button id="disconnectBtn" class="btn btn-secondary" style="display: none; border-color: #ff4444; color: #ff4444;">DISCONNECT</button>
                    <button id="mpBtn" class="btn">MULTIPLAYER</button>
                    <button id="optionsBtn" class="btn" style="border-color: #00ccff; color: #00ccff;">OPTIONS</button>
                    <button id="aboutBtn" class="btn btn-secondary">ABOUT</button>
                </div>

                <!-- Options Menu -->
                <div id="optionsMenu" class="menu-layer">
                    <div class="menu-window">
                        <div class="menu-header">OPTIONS</div>
                        <div class="stat-label" style="margin-bottom: 15px; font-size: 12px;">RESOLUTION</div>
                        <button class="btn res-btn" onclick="setResolution(720)">720p</button>
                        <button class="btn res-btn" onclick="setResolution(1080)">1080p</button>
                        <button class="btn res-btn" onclick="setResolution(1440)">1440p</button>
                        <div class="stat-label" style="margin-top: 30px; margin-bottom: 15px; font-size: 12px;">AUDIO & VISUALS</div>
                        <button id="musicToggleBtn" class="btn" style="border-color: #00ffcc; color: #00ffcc;">MUSIC: ON</button>
                        <button id="crtToggleBtn" class="btn" style="border-color: #00ffcc; color: #00ffcc;">CRT EFFECT: ON</button>
                        <button id="fsToggleBtn" class="btn" style="border-color: #00ffcc; color: #00ffcc;">FULLSCREEN: OFF</button>
                        <div class="stat-label" style="margin-top: 20px; font-size: 12px;">VOLUME <span id="volumeValue">50%</span></div>
                        <input type="range" id="volumeSlider" min="0" max="100" value="50" class="slider">
                        <button id="optionsBackBtn" class="btn btn-secondary" style="margin-top: 30px;">BACK</button>
                    </div>
                </div>

                <!-- About Menu -->
                <div id="aboutMenu" class="menu-layer">
                    <div class="menu-window">
                        <div class="menu-header">SYSTEM INFO</div>
                        <div class="stat-box" style="width: 100%; margin-bottom: 15px;">
                            <div class="stat-label">App ID</div>
                            <div id="aboutAppId" style="font-size: 10px; word-break: break-all; color: #fff; line-height: 1.5;">Loading...</div>
                        </div>
                        <div class="stat-box" style="width: 100%; margin-bottom: 15px;">
                            <div class="stat-label">User ID</div>
                            <div id="aboutUserId" style="font-size: 10px; word-break: break-all; color: #fff; line-height: 1.5;">Not Logged In</div>
                        </div>
                        <button id="aboutBackBtn" class="btn btn-secondary">BACK</button>
                    </div>
                </div>

                <!-- Multiplayer Menu -->
                <div id="mpMenu" class="menu-layer">
                    <div class="menu-window">
                        <div class="menu-header">MULTIPLAYER</div>
                        
                        <div id="mpOptions">
                            <button id="hostBtn" class="btn">HOST GAME</button>
                            <div class="input-group">
                                <div class="stat-label" style="margin-bottom: 0;">OR JOIN GAME</div>
                                <input type="text" id="joinCodeInput" placeholder="CODE" maxlength="6">
                                <button id="joinBtn" class="btn">JOIN</button>
                            </div>
                            <button id="backBtn" class="btn btn-secondary">BACK</button>
                        </div>

                        <!-- NEW LOBBY SYSTEM -->
                        <div id="mpLobby" style="display:none; text-align: center; width: 100%;">
                            <div class="stat-label">ROOM CODE</div>
                            <div id="roomCodeDisplay" class="room-code-display">...</div>
                            
                            <div class="status-msg" id="lobbyStatus">CONNECTING...</div>
                            
                            <div class="stat-label" style="margin-top: 20px;">CONNECTED PLAYERS</div>
                            <div id="lobbyPlayerList" class="player-list">
                                <!-- Dynamic List -->
                            </div>
                            
                            <div id="lobbyControls">
                                <button id="readyBtn" class="btn" style="border-color: #ff0; color: #ff0;">NOT READY</button>
                                <button id="startGameBtn" class="btn" style="border-color: #0f0; color: #0f0; display:none;" disabled>START GAME</button>
                            </div>

                            <button id="cancelHostBtn" class="btn btn-secondary" style="margin-top: 20px;">LEAVE LOBBY</button>
                        </div>
                        
                        <div class="status-msg" id="mpStatus"></div>
                    </div>
                </div>
                
                <div class="debug-info" id="debugInfo">Initializing System...</div>
            </div>

            <!-- OPPONENT GRID (Dynamic for 4 Players) -->
            <div class="opponents-wrapper" id="opponentContainer">
                 <!-- Opponent Slots generated via JS -->
            </div>
        </div>

        <!-- CHAT UI -->
        <div id="mpChat" class="chat-container">
            <div class="chat-header">COMMUNICATIONS</div>
            <div id="chatMessages" class="chat-messages"></div>
            <div class="chat-input-area">
                <input type="text" id="chatInput" placeholder="MESSAGE..." maxlength="50" autocomplete="off">
                <button id="chatSendBtn">SEND</button>
            </div>
        </div>
    </div>

    <!-- Modules for Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'neon-blocks';

        let currentUser = null;
        let currentGameId = null;
        let isHost = false;
        let isReady = false; // Lobby Ready Status
        
        // Listeners
        let gameSessionUnsubscribe = null;
        let chatUnsubscribe = null;
        let opponentListeners = []; // Array of unsub functions

        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };
        initAuth();
        
        const startBtn = document.getElementById('startBtn');
        const mpBtn = document.getElementById('mpBtn');
        const debugInfo = document.getElementById('debugInfo');
        startBtn.disabled = true; mpBtn.disabled = true; startBtn.innerText = "LOADING..."; mpBtn.style.opacity = "0.5";

        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            if (user) {
                startBtn.disabled = false; mpBtn.disabled = false; startBtn.innerText = "SINGLE PLAYER"; mpBtn.style.opacity = "1";
                debugInfo.innerText = `APP: ${appId.substring(0,6)} | UID: ${user.uid.substring(0,6)}`;
            }
        });

        // --- CONFIG & STATE ---
        const FPS = 120; 
        const MIN_FRAME_TIME = 1000 / FPS;
        const COLS = 10; const ROWS = 20;
        let BLOCK_SIZE = 52; 
        
        const CANVAS = document.getElementById('gameBoard');
        const CTX = CANVAS.getContext('2d');
        const NEXT_CANVAS = document.getElementById('nextPiece');
        const NEXT_CTX = NEXT_CANVAS.getContext('2d');
        const HOLD_CANVAS = document.getElementById('holdPiece');
        const HOLD_CTX = HOLD_CANVAS.getContext('2d');

        const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#808080'];
        const PIECES = [null, [[0,1,0],[1,1,1],[0,0,0]], [[0,2,0,0],[0,2,0,0],[0,2,0,0],[0,2,0,0]], [[0,3,3],[3,3,0],[0,0,0]], [[4,4,0],[0,4,4],[0,0,0]], [[0,0,5],[5,5,5],[0,0,0]], [[6,6],[6,6]], [[7,0,0],[7,7,7],[0,0,0]]];

        let grid = createGrid(COLS, ROWS);
        let player = { pos: {x: 0, y: 0}, matrix: null, score: 0, level: 1, lines: 0 };
        let nextPieceMatrix = null; let holdPieceMatrix = null; let canHold = true;
        let dropCounter = 0; let dropInterval = 1000;
        let lastSpeedIncreaseScore = 0; const SPEED_BUMP_THRESHOLD = 5000;
        
        let isPaused = false; let isGameOver = false; let gameRunning = false; 
        let isAnimating = false; let animationTimer = 0; let clearingRows = []; const ANIMATION_DURATION = 300;
        
        const keyState = { ArrowLeft: false, ArrowRight: false, KeyA: false, KeyD: false };
        const moveTimers = { KeyA: 0, KeyD: 0 };
        const DAS_DELAY = 160; const DAS_SPEED = 50;
        let gameLoopId = null; let lastFrameTime = 0;

        let isMultiplayer = false;
        let lastSyncTime = 0;
        let lastAttackTime = 0; 
        let lastReceivedAttackTime = 0; 
        
        // Map of Opponents: UID -> { grid, score, active: {matrix, pos} }
        let opponents = {}; 

        // --- AUDIO (Same as before) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();
        let musicEnabled = true; let crtEnabled = true; let masterVolume = 0.5;
        let nextNoteTime = 0; let noteIndex = 0; let musicTimerID = null; let musicTempo = 145;
        const lookahead = 25.0; const scheduleAheadTime = 0.1;
        const MELODY = [
            {f: 659.25, d: 0.5}, {f: 0, d: 0.25}, {f: 659.25, d: 0.25}, {f: 493.88, d: 0.5}, {f: 523.25, d: 0.5},
            {f: 587.33, d: 0.5}, {f: 0, d: 0.25}, {f: 587.33, d: 0.25}, {f: 523.25, d: 0.5}, {f: 493.88, d: 0.5},
            {f: 440.00, d: 0.5}, {f: 0, d: 0.25}, {f: 440.00, d: 0.25}, {f: 523.25, d: 0.5}, {f: 659.25, d: 0.5},
            {f: 587.33, d: 0.5}, {f: 523.25, d: 0.5}, {f: 493.88, d: 0.75}, {f: 493.88, d: 0.25},
            {f: 523.25, d: 0.5}, {f: 587.33, d: 0.5}, {f: 659.25, d: 0.5}, {f: 523.25, d: 0.5},
            {f: 440.00, d: 0.5}, {f: 440.00, d: 0.5}, {f: 0, d: 1},
            {f: 587.33, d: 0.75}, {f: 698.46, d: 0.25}, {f: 880.00, d: 0.5}, {f: 0, d: 0.25}, {f: 880.00, d: 0.25},
            {f: 783.99, d: 0.5}, {f: 698.46, d: 0.5}, {f: 659.25, d: 0.75}, {f: 0, d: 0.25},
            {f: 523.25, d: 0.5}, {f: 659.25, d: 0.5}, {f: 587.33, d: 0.5}, {f: 0, d: 0.25}, {f: 587.33, d: 0.25},
            {f: 523.25, d: 0.5}, {f: 493.88, d: 0.5}, {f: 493.88, d: 0.5}, {f: 0, d: 0.5},
            {f: 523.25, d: 0.25}, {f: 587.33, d: 0.25}, {f: 659.25, d: 0.5},
            {f: 523.25, d: 0.5}, {f: 440.00, d: 0.5}, {f: 440.00, d: 0.5}, {f: 220.00, d: 0.5},
            {f: 440.00, d: 0.25}, {f: 880.00, d: 0.25}, {f: 440.00, d: 0.5}, {f: 0, d: 1}
        ];

        function playLineClear() { if(!musicEnabled) return; const now=audioCtx.currentTime;const osc=audioCtx.createOscillator();const gain=audioCtx.createGain();osc.type='square';osc.frequency.setValueAtTime(440,now);osc.frequency.linearRampToValueAtTime(880,now+0.1);const vol=0.1*masterVolume;gain.gain.setValueAtTime(vol,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.1);osc.connect(gain);gain.connect(audioCtx.destination);osc.start(now);osc.stop(now+0.1);}
        function playThump() { if(!musicEnabled) return; const osc=audioCtx.createOscillator();const gain=audioCtx.createGain();osc.type='square';osc.frequency.setValueAtTime(150,audioCtx.currentTime);osc.frequency.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+0.15);const vol=0.1*masterVolume;gain.gain.setValueAtTime(vol,audioCtx.currentTime);const endVol=Math.max(0.0001,0.001*masterVolume);gain.gain.exponentialRampToValueAtTime(endVol,audioCtx.currentTime+0.1);osc.connect(gain);gain.connect(audioCtx.destination);osc.start();osc.stop(audioCtx.currentTime+0.15);}
        function playTone(freq,d,t){if(!musicEnabled||freq<=0||masterVolume<=0)return;const osc=audioCtx.createOscillator();const gain=audioCtx.createGain();osc.type='square';osc.frequency.value=freq;osc.connect(gain);gain.connect(audioCtx.destination);const vol=0.05*masterVolume;gain.gain.setValueAtTime(vol,t);const endVol=Math.max(0.0001,0.01*masterVolume);gain.gain.exponentialRampToValueAtTime(endVol,t+d-0.05);osc.start(t);osc.stop(t+d);}
        function scheduler(){while(nextNoteTime<audioCtx.currentTime+scheduleAheadTime){const note=MELODY[noteIndex];const s=60.0/musicTempo;const d=note.d*s;playTone(note.f,d,nextNoteTime);nextNoteTime+=d;noteIndex++;if(noteIndex>=MELODY.length)noteIndex=0;}musicTimerID=setTimeout(scheduler,lookahead);}
        function startMusic(){if(!musicEnabled)return;if(audioCtx.state==='suspended')audioCtx.resume();if(musicTimerID)clearTimeout(musicTimerID);nextNoteTime=audioCtx.currentTime+0.1;noteIndex=0;scheduler();}
        function stopMusic(){if(musicTimerID)clearTimeout(musicTimerID);musicTimerID=null;}
        function toggleMusic(){musicEnabled=!musicEnabled;const btn=document.getElementById('musicToggleBtn');if(musicEnabled){btn.innerText="MUSIC: ON";btn.style.borderColor="#00ffcc";btn.style.color="#00ffcc";if(gameRunning&&!isPaused)startMusic();}else{btn.innerText="MUSIC: OFF";btn.style.borderColor="#666";btn.style.color="#666";stopMusic();}}
        function toggleCRT(){crtEnabled=!crtEnabled;const btn=document.getElementById('crtToggleBtn');if(crtEnabled){btn.innerText="CRT EFFECT: ON";btn.style.borderColor="#00ffcc";btn.style.color="#00ffcc";document.body.classList.add('crt-enabled');}else{btn.innerText="CRT EFFECT: OFF";btn.style.borderColor="#666";btn.style.color="#666";document.body.classList.remove('crt-enabled');}}
        function toggleFullscreen(){const btn=document.getElementById('fsToggleBtn');if(!document.fullscreenElement){document.documentElement.requestFullscreen().catch(e=>{console.error(e);});}else{if(document.exitFullscreen){document.exitFullscreen();}}}
        document.addEventListener('fullscreenchange',(e)=>{const btn=document.getElementById('fsToggleBtn');if(document.fullscreenElement){btn.innerText="FULLSCREEN: ON";btn.style.borderColor="#00ffcc";btn.style.color="#00ffcc";}else{btn.innerText="FULLSCREEN: OFF";btn.style.borderColor="#666";btn.style.color="#666";}resizeGame();});

        // Background Animation
        const BG_CANVAS = document.getElementById('bgCanvas'); const BG_CTX = BG_CANVAS.getContext('2d'); let bgAnimationId = null; let bgPieces = [];
        function initMenuBackground(){BG_CANVAS.width=window.innerWidth;BG_CANVAS.height=window.innerHeight;BG_CANVAS.classList.add('visible');bgPieces=[];for(let i=0;i<15;i++)spawnBgPiece(true);if(!bgAnimationId)animateMenuBackground();}
        function spawnBgPiece(randomY=false){const pieceIdx=(Math.random()*7|0)+1;const piece={matrix:PIECES[pieceIdx],x:Math.floor(Math.random()*(BG_CANVAS.width/BLOCK_SIZE)),y:randomY?Math.floor(Math.random()*(BG_CANVAS.height/BLOCK_SIZE)):-4,speed:0.05+Math.random()*0.1,lastMove:0};bgPieces.push(piece);}
        function animateMenuBackground(){BG_CTX.fillStyle='#000000';BG_CTX.fillRect(0,0,BG_CANVAS.width,BG_CANVAS.height);for(let i=bgPieces.length-1;i>=0;i--){let p=bgPieces[i];p.y+=p.speed;drawBgMatrix(p.matrix,p.x*BLOCK_SIZE,p.y*BLOCK_SIZE);if(p.y*BLOCK_SIZE>BG_CANVAS.height){bgPieces.splice(i,1);spawnBgPiece();}}bgAnimationId=requestAnimationFrame(animateMenuBackground);}
        function drawBgMatrix(m,sx,sy){m.forEach((r,y)=>{r.forEach((v,x)=>{if(v!==0){BG_CTX.fillStyle=COLORS[v];BG_CTX.globalAlpha=0.15;BG_CTX.fillRect(sx+x*BLOCK_SIZE,sy+y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);BG_CTX.strokeStyle='rgba(255,255,255,0.05)';BG_CTX.strokeRect(sx+x*BLOCK_SIZE,sy+y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);BG_CTX.globalAlpha=1.0;}});});}
        function stopMenuBackground(){BG_CANVAS.classList.remove('visible');setTimeout(()=>{if(bgAnimationId){cancelAnimationFrame(bgAnimationId);bgAnimationId=null;}},500);}

        // --- GAME LOGIC ---
        function createGrid(w, h) { const m = []; while (h--) m.push(new Array(w).fill(0)); return m; }
        function collide(arena, player) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) { return true; } } } return false; }
        function drawMatrix(matrix, offset, context, ghostMode=false) { matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { context.fillStyle = ghostMode ? '#666' : COLORS[value]; context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); context.fillStyle = ghostMode ? 'rgba(255,255,255,0.1)' : 'rgba(255, 255, 255, 0.2)'; context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, 3); context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, 3, BLOCK_SIZE); context.strokeStyle = 'rgba(0, 0, 0, 0.3)'; context.lineWidth = 2; context.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); } }); }); }

        function draw() {
            // Local Player
            CTX.fillStyle = '#000'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
            drawGridLines(CTX, CANVAS.width, CANVAS.height);
            drawMatrix(grid, {x: 0, y: 0}, CTX);
            if (isAnimating && clearingRows.length > 0) { CTX.fillStyle = `rgba(255, 255, 255, ${Math.sin(Date.now() / 20) * 0.5 + 0.5})`; clearingRows.forEach(y => CTX.fillRect(0, y * BLOCK_SIZE, CANVAS.width, BLOCK_SIZE)); }
            if (!isAnimating && !isGameOver) { drawMatrix(player.matrix, player.pos, CTX); const ghostPos = { ...player.pos }; while (!collide(grid, { matrix: player.matrix, pos: ghostPos })) ghostPos.y++; ghostPos.y--; CTX.globalAlpha = 0.2; drawMatrix(player.matrix, ghostPos, CTX); CTX.globalAlpha = 1.0; }

            // Opponents
            if (isMultiplayer) {
                const oppContainer = document.getElementById('opponentContainer');
                const canvases = oppContainer.querySelectorAll('.opp-canvas');
                const oppIds = Object.keys(opponents);
                
                canvases.forEach((canvas, index) => {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#050505';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (index < oppIds.length) {
                        const oppId = oppIds[index];
                        const oppData = opponents[oppId];
                        const scale = canvas.width / (COLS * BLOCK_SIZE);
                        ctx.save();
                        ctx.scale(scale, scale);
                        drawGridLines(ctx, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                        if (oppData.grid) drawMatrix(oppData.grid, {x: 0, y: 0}, ctx, true);
                        if (oppData.active) {
                             ctx.globalAlpha = 0.6;
                             drawMatrix(oppData.active.matrix, oppData.active.pos, ctx, true);
                             ctx.globalAlpha = 1.0;
                        }
                        ctx.restore();
                    } else {
                        ctx.fillStyle = '#333';
                        ctx.font = '10px "Press Start 2P"';
                        ctx.textAlign = 'center';
                        ctx.fillText("EMPTY", canvas.width/2, canvas.height/2);
                    }
                });
            }

            drawPiecePreview(HOLD_CTX, holdPieceMatrix, HOLD_CANVAS);
            drawPiecePreview(NEXT_CTX, nextPieceMatrix, NEXT_CANVAS);
        }

        function drawGridLines(ctx, w, h) { ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; for(let i = 0; i <= COLS; i++) { ctx.beginPath(); ctx.moveTo(i * BLOCK_SIZE, 0); ctx.lineTo(i * BLOCK_SIZE, h); ctx.stroke(); } for(let i = 0; i <= ROWS; i++) { ctx.beginPath(); ctx.moveTo(0, i * BLOCK_SIZE); ctx.lineTo(w, i * BLOCK_SIZE); ctx.stroke(); } }
        function drawPiecePreview(ctx, m, c) { ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, c.width, c.height); if (m) { const ox = (4 - m[0].length) / 2; const oy = (4 - m.length) / 2; ctx.save(); ctx.scale(0.6, 0.6); drawMatrix(m, {x: ox + 0.5, y: oy + 0.5}, ctx); ctx.restore(); } }

        // --- MULTIPLAYER LOGIC ---
        const generateCode = () => Math.floor(100000 + Math.random() * 900000).toString();

        async function syncMultiplayerState(force = false) {
            if (!isMultiplayer || !currentUser || !currentGameId) return;
            const now = Date.now();
            if (!force && now - lastSyncTime < 50) return;
            try {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'gamestates', currentUser.uid), {
                    grid: JSON.stringify(grid), score: player.score, lastAttackTime: lastAttackTime,
                    active: { matrix: JSON.stringify(player.matrix), pos: player.pos }, timestamp: now,
                    sessionId: currentGameId
                });
                lastSyncTime = now;
            } catch (e) { console.error(e); }
        }

        // HOST
        async function hostGame() {
            if (!currentUser) return;
            document.getElementById('mpOptions').style.display = 'none';
            document.getElementById('mpLobby').style.display = 'block';
            document.getElementById('roomCodeDisplay').innerText = "LOADING...";
            document.getElementById('mpStatus').innerText = ""; // Clear status
            
            const code = generateCode();
            currentGameId = code; isHost = true; isReady = false;
            updateReadyBtn();

            try {
                const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', code);
                const initialPlayers = {};
                initialPlayers[currentUser.uid] = { name: "P1 (HOST)", ready: false, joinedAt: Date.now() };

                await setDoc(sessionRef, {
                    host: currentUser.uid, code: code, status: 'waiting',
                    players: initialPlayers, timestamp: Date.now(), messages: []
                });

                document.getElementById('roomCodeDisplay').innerText = code;
                document.getElementById('lobbyStatus').innerText = "WAITING FOR PLAYERS...";
                if(isHost) document.getElementById('startGameBtn').style.display = 'inline-block';

                setupLobbyListener();

            } catch (e) { console.error(e); document.getElementById('mpStatus').innerText = "Error: " + e.message; }
        }

        // JOIN
        async function joinGame() {
            if (!currentUser) return;
            const code = document.getElementById('joinCodeInput').value.trim();
            if (code.length !== 6) { document.getElementById('mpStatus').innerText = "INVALID CODE"; return; }
            
            document.getElementById('mpStatus').innerText = "SEARCHING...";
            const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', code);
            
            try {
                const docSnap = await getDoc(sessionRef);
                if (!docSnap.exists()) { document.getElementById('mpStatus').innerText = "ROOM NOT FOUND"; return; }
                const data = docSnap.data();
                
                if (data.status !== 'waiting') { document.getElementById('mpStatus').innerText = "GAME IN PROGRESS"; return; }

                // CHECK IF ALREADY IN (Fix for "Only shows P2" bug)
                if (data.players && data.players[currentUser.uid]) {
                    // Already in, just restore session
                    currentGameId = code;
                    isHost = (data.host === currentUser.uid);
                    isReady = data.players[currentUser.uid].ready;
                } else {
                    // New player
                    const playerCount = Object.keys(data.players || {}).length;
                    if (playerCount >= 4) { document.getElementById('mpStatus').innerText = "ROOM FULL"; return; }
                    
                    const newPlayerKey = `players.${currentUser.uid}`;
                    const pNum = playerCount + 1;
                    await updateDoc(sessionRef, {
                        [newPlayerKey]: { name: `P${pNum} (GUEST)`, ready: false, joinedAt: Date.now() }
                    });
                    currentGameId = code; isHost = false; isReady = false;
                }

                // UI Success State
                document.getElementById('mpStatus').innerText = "";
                updateReadyBtn();
                
                document.getElementById('mpOptions').style.display = 'none';
                document.getElementById('mpLobby').style.display = 'block';
                document.getElementById('roomCodeDisplay').innerText = code;
                
                // FIX: Explicitly set status text so it doesn't stay stuck on "CONNECTING..."
                document.getElementById('lobbyStatus').innerText = isHost ? "WAITING FOR PLAYERS..." : "CONNECTED! WAITING FOR HOST...";
                
                document.getElementById('startGameBtn').style.display = isHost ? 'inline-block' : 'none';

                setupLobbyListener();

            } catch (e) { console.error(e); document.getElementById('mpStatus').innerText = "Join Error: " + e.message; }
        }

        function setupLobbyListener() {
            if(!currentGameId) return;
            const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', currentGameId);
            
            gameSessionUnsubscribe = onSnapshot(sessionRef, (snap) => {
                if(!snap.exists()) return;
                const data = snap.data();
                
                // Render Player List
                const list = document.getElementById('lobbyPlayerList');
                list.innerHTML = '';
                const players = data.players || {};
                const uids = Object.keys(players);
                
                let allReady = true;
                
                uids.forEach(uid => {
                    const p = players[uid];
                    const div = document.createElement('div');
                    const isMe = uid === currentUser.uid;
                    div.className = `player-item ${p.ready ? 'ready' : 'not-ready'}`;
                    div.innerHTML = `<span>${p.name || 'PLAYER'} ${isMe ? '(YOU)' : ''}</span><span class="status-pill">${p.ready ? 'READY' : 'WAITING'}</span>`;
                    list.appendChild(div);
                    if(!p.ready) allReady = false;
                });

                if(isHost) {
                    const startBtn = document.getElementById('startGameBtn');
                    startBtn.disabled = !allReady || uids.length < 2; 
                    startBtn.style.opacity = startBtn.disabled ? 0.5 : 1;
                }

                // Check for Game Start
                if(data.status === 'playing' && !isMultiplayer) {
                    startMultiplayerMatch(uids);
                }
            });
        }

        async function toggleReady() {
            if(!currentGameId || !currentUser) return;
            isReady = !isReady;
            updateReadyBtn();
            
            const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', currentGameId);
            const playerReadyKey = `players.${currentUser.uid}.ready`;
            await updateDoc(sessionRef, { [playerReadyKey]: isReady });
        }

        async function tryStartGame() {
            if(!isHost || !currentGameId) return;
            const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', currentGameId);
            await updateDoc(sessionRef, { status: 'playing' });
        }

        function updateReadyBtn() {
            const btn = document.getElementById('readyBtn');
            if(isReady) {
                btn.innerText = "READY!";
                btn.style.borderColor = "#0f0"; btn.style.color = "#0f0";
            } else {
                btn.innerText = "NOT READY";
                btn.style.borderColor = "#ff0"; btn.style.color = "#ff0";
            }
        }

        function startMultiplayerMatch(playerUids) {
            isMultiplayer = true;
            lastReceivedAttackTime = 0;
            
            hideAllMenus();
            document.getElementById('opponentContainer').style.display = 'flex';
            document.getElementById('mpChat').style.display = 'flex';
            document.getElementById('chatMessages').innerHTML = '';
            
            const oppContainer = document.getElementById('opponentContainer');
            oppContainer.innerHTML = ''; 
            opponents = {}; 

            const otherUids = playerUids.filter(uid => uid !== currentUser.uid);
            
            otherUids.forEach((uid, idx) => {
                const slot = document.createElement('div');
                slot.className = 'opponent-slot';
                slot.innerHTML = `<div class="opponent-header">P${idx + 2}</div><canvas class="opp-canvas" width="173" height="346"></canvas>`;
                oppContainer.appendChild(slot);
                
                opponents[uid] = { grid: null, score: 0, active: null };
                
                const ref = doc(db, 'artifacts', appId, 'public', 'data', 'gamestates', uid);
                const unsub = onSnapshot(ref, (s) => {
                    if(s.exists()) {
                        const d = s.data();
                        if(d.sessionId === currentGameId) {
                            opponents[uid].grid = JSON.parse(d.grid);
                            opponents[uid].active = d.active ? { matrix: JSON.parse(d.active.matrix), pos: d.active.pos } : null;
                            
                            if (d.lastAttackTime && d.lastAttackTime > lastReceivedAttackTime) {
                                if (lastReceivedAttackTime !== 0) addGarbageRow();
                                lastReceivedAttackTime = d.lastAttackTime;
                            }
                            if (lastReceivedAttackTime === 0 && d.lastAttackTime) lastReceivedAttackTime = d.lastAttackTime;
                        }
                    }
                });
                opponentListeners.push(unsub);
            });
            
            setupChatListener(); 
            resizeGame(); 
            startGame(); 
        }
        
        // ... Rest of the code remains identical ...
        function setupChatListener() { if (!currentGameId) return; const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', currentGameId); chatUnsubscribe = onSnapshot(sessionRef, (docSnap) => { if (docSnap.exists()) { const data = docSnap.data(); if (data.messages) { const players = data.players || {}; renderMessages(data.messages, players); } } }); }
        function renderMessages(messages, players) { const chatDiv = document.getElementById('chatMessages'); chatDiv.innerHTML = ''; messages.forEach(msg => { const msgEl = document.createElement('div'); const isMine = msg.sender === currentUser.uid; let pName = "PLAYER"; let pClass = "p1"; if(players[msg.sender]) { pName = players[msg.sender].name.split(' ')[0]; if(pName === "P1") pClass = "p1"; else if(pName === "P2") pClass = "p2"; else if(pName === "P3") pClass = "p3"; else if(pName === "P4") pClass = "p4"; } msgEl.className = `chat-msg ${pClass}`; const senderLabel = document.createElement('span'); senderLabel.className = 'sender'; senderLabel.innerText = pName + ":"; const textNode = document.createElement('span'); textNode.className = 'content'; textNode.innerText = msg.text; msgEl.appendChild(senderLabel); msgEl.appendChild(textNode); chatDiv.appendChild(msgEl); }); chatDiv.scrollTop = chatDiv.scrollHeight; }
        async function sendMessage() { if (!currentUser || !currentGameId) return; const input = document.getElementById('chatInput'); const text = input.value.trim(); if (!text) return; input.value = ''; try { const sessionRef = doc(db, 'artifacts', appId, 'public', 'data', 'sessions', currentGameId); await updateDoc(sessionRef, { messages: arrayUnion({ sender: currentUser.uid, text: text, timestamp: Date.now() }) }); } catch(e) { console.error("Chat error:", e); } }
        
        // Standard functions
        function merge(arena, player) { player.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { arena[y + player.pos.y][x + player.pos.x] = value; } }); }); syncMultiplayerState(true); }
        function rotate(matrix, dir) { for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse(); }
        function playerDrop() { player.pos.y++; if (collide(grid, player)) { player.pos.y--; merge(grid, player); const fullRows = []; grid.forEach((row, y) => { if (row.every(value => value !== 0)) fullRows.push(y); }); if (fullRows.length > 0) startLineClearAnimation(fullRows); else { playerReset(); updateScore(); } } dropCounter = 0; }
        function playerHardDrop() { while (!collide(grid, player)) player.pos.y++; player.pos.y--; merge(grid, player); playThump(); const fullRows = []; grid.forEach((row, y) => { if (row.every(value => value !== 0)) fullRows.push(y); }); if (fullRows.length > 0) startLineClearAnimation(fullRows); else { playerReset(); updateScore(); } dropCounter = 0; }
        function startLineClearAnimation(rows) { isAnimating = true; clearingRows = rows; animationTimer = 0; }
        function finalizeLineClear() { let rowCount = 0; clearingRows.sort((a, b) => a - b); for (let i = 0; i < clearingRows.length; i++) { const y = clearingRows[i]; const row = grid.splice(y, 1)[0].fill(0); grid.unshift(row); rowCount++; } if (rowCount > 0) { playLineClear(); const lineScores = [0, 40, 100, 300, 1200]; player.score += lineScores[rowCount] * player.level; player.lines += rowCount; player.level = Math.floor(player.lines / 10) + 1; if (rowCount >= 4 && isMultiplayer) { lastAttackTime = Date.now(); } } updateScore(); playerReset(); isAnimating = false; clearingRows = []; syncMultiplayerState(true); }
        function addGarbageRow() { grid.shift(); const row = new Array(COLS).fill(8); const hole = Math.floor(Math.random() * COLS); row[hole] = 0; grid.push(row); player.pos.y--; draw(); }
        function playerMove(dir) { player.pos.x += dir; if (collide(grid, player)) player.pos.x -= dir; }
        function playerRotate(dir) { const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir); while (collide(grid, player)) { player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; } } }
        function playerHold() { if (!canHold) return; if (!holdPieceMatrix) { holdPieceMatrix = player.matrix; playerReset(); } else { const temp = player.matrix; player.matrix = holdPieceMatrix; holdPieceMatrix = temp; player.pos.y = 0; player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0); } canHold = false; }
        function getRandomPiece() { const type = 'ILJOTSZ'[Math.floor(Math.random() * 7)]; let idx = 1; if(type === 'I') idx = 2; else if(type === 'S') idx = 3; else if(type === 'Z') idx = 4; else if(type === 'L') idx = 5; else if(type === 'O') idx = 6; else if(type === 'J') idx = 7; return PIECES[idx].map(row => [...row]); }
        function playerReset() { if (!nextPieceMatrix) nextPieceMatrix = getRandomPiece(); player.matrix = nextPieceMatrix; nextPieceMatrix = getRandomPiece(); player.pos.y = 0; player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0); canHold = true; if (collide(grid, player)) { isGameOver = true; document.getElementById('overlayTitle').innerText = "GAME OVER"; if (isMultiplayer) { document.getElementById('startBtn').style.display = 'none'; document.getElementById('mpBtn').style.display = 'none'; document.getElementById('resumeBtn').style.display = 'none'; document.getElementById('disconnectBtn').style.display = 'block'; } else { document.getElementById('startBtn').innerText = "RESTART"; document.getElementById('startBtn').style.display = 'block'; document.getElementById('mpBtn').style.display = 'block'; document.getElementById('disconnectBtn').style.display = 'none'; } showMenu('overlay'); initMenuBackground(); stopGameLoop(); } }
        function disconnectGame() { if (gameSessionUnsubscribe) gameSessionUnsubscribe(); opponentListeners.forEach(u => u()); opponentListeners = []; if (chatUnsubscribe) chatUnsubscribe(); gameSessionUnsubscribe = null; chatUnsubscribe = null; isMultiplayer = false; isHost = false; currentGameId = null; document.getElementById('opponentContainer').style.display = 'none'; document.getElementById('mpChat').style.display = 'none'; document.getElementById('disconnectBtn').style.display = 'none'; document.getElementById('startBtn').style.display = 'block'; document.getElementById('startBtn').innerText = "SINGLE PLAYER"; document.getElementById('mpBtn').style.display = 'block'; document.getElementById('overlayTitle').innerHTML = "NEON<br>BLOCKS"; showMenu('overlay'); gameRunning = false; isGameOver = false; isPaused = false; initMenuBackground(); resizeGame(); }
        function updateScore() { document.getElementById('score').innerText = player.score; document.getElementById('level').innerText = player.level; if (player.score - lastSpeedIncreaseScore >= SPEED_BUMP_THRESHOLD) { lastSpeedIncreaseScore = Math.floor(player.score / SPEED_BUMP_THRESHOLD) * SPEED_BUMP_THRESHOLD; dropInterval = Math.max(50, dropInterval * 0.9); } if (isMultiplayer) syncMultiplayerState(true); }
        window.setResolution = function(height) { BLOCK_SIZE = height / ROWS; CANVAS.height = height; CANVAS.width = BLOCK_SIZE * COLS; if (player.matrix) draw(); document.querySelectorAll('.res-btn').forEach(btn => { if(btn.innerText.includes(height)) btn.style.background = 'var(--accent-color)'; else btn.style.background = 'transparent'; }); if(typeof resizeGame === 'function') resizeGame(); }
        
        function update(dt) { if (isPaused || isGameOver) return; if (isAnimating) { animationTimer += dt; if (animationTimer >= ANIMATION_DURATION) finalizeLineClear(); draw(); return; } if (keyState.KeyA || keyState.ArrowLeft) { moveTimers.KeyA += dt; if (moveTimers.KeyA > DAS_DELAY) { moveTimers.KeyA -= DAS_SPEED; playerMove(-1); } } if (keyState.KeyD || keyState.ArrowRight) { moveTimers.KeyD += dt; if (moveTimers.KeyD > DAS_DELAY) { moveTimers.KeyD -= DAS_SPEED; playerMove(1); } } dropCounter += dt; if (dropCounter > dropInterval) playerDrop(); draw(); if (isMultiplayer) syncMultiplayerState(); }
        function startGame() { grid = createGrid(COLS, ROWS); player.score = 0; player.lines = 0; player.level = 1; lastSpeedIncreaseScore = 0; updateScore(); dropInterval = 1000; isGameOver = false; isPaused = false; isAnimating = false; gameRunning = true; keyState.KeyA = false; keyState.KeyD = false; keyState.ArrowLeft = false; keyState.ArrowRight = false; playerReset(); hideAllMenus(); document.getElementById('resumeBtn').style.display = "none"; document.getElementById('disconnectBtn').style.display = "none"; stopMenuBackground(); startMusic(); if (gameLoopId) cancelAnimationFrame(gameLoopId); lastFrameTime = performance.now(); gameLoopId = requestAnimationFrame(gameLoop); draw(); }
        function gameLoop(ts) { if (!gameRunning) return; const dt = ts - lastFrameTime; if (dt >= MIN_FRAME_TIME) { update(Math.min(dt, 100)); lastFrameTime = ts - (dt % MIN_FRAME_TIME); } if (!isGameOver) { gameLoopId = requestAnimationFrame(gameLoop); } }
        function stopGameLoop() { if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; stopMusic(); }
        function hideAllMenus() { document.querySelectorAll('.menu-layer').forEach(el => el.classList.remove('active')); }
        function showMenu(id) { hideAllMenus(); const el = document.getElementById(id); if (el) el.classList.add('active'); if (id === 'overlay') initMenuBackground(); }
        function toggleMenu() { const isMenuOpen = document.querySelector('.menu-layer.active'); if (isMenuOpen) { if (gameRunning) { hideAllMenus(); stopMenuBackground(); if (!isMultiplayer) isPaused = false; if(musicEnabled) startMusic(); } } else { if (gameRunning) { document.getElementById('resumeBtn').style.display = 'block'; document.getElementById('startBtn').innerText = "NEW GAME"; if (isMultiplayer) { document.getElementById('disconnectBtn').style.display = 'block'; document.getElementById('startBtn').style.display = 'none'; document.getElementById('mpBtn').style.display = 'none'; } else { document.getElementById('disconnectBtn').style.display = 'none'; document.getElementById('startBtn').style.display = 'block'; document.getElementById('mpBtn').style.display = 'block'; } } else { document.getElementById('resumeBtn').style.display = 'none'; document.getElementById('startBtn').innerText = "SINGLE PLAYER"; document.getElementById('disconnectBtn').style.display = 'none'; } showMenu('overlay'); initMenuBackground(); if (!isMultiplayer) isPaused = true; stopMusic(); } }
        
        initMenuBackground(); showMenu('overlay');
        document.addEventListener('keydown', e => { if (e.target.tagName === 'INPUT') return; if (e.code === 'Escape') { const activeMenu = document.querySelector('.menu-layer.active'); if (activeMenu && activeMenu.id !== 'overlay') { showMenu('overlay'); return; } toggleMenu(); return; } if (document.querySelector('.menu-layer.active')) return; if (isGameOver) return; if (e.code === 'KeyP') { isPaused = !isPaused; if (isPaused) { CTX.fillStyle = 'rgba(0,0,0,0.5)'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height); CTX.fillStyle = '#fff'; CTX.font = '40px "Press Start 2P"'; CTX.textAlign = 'center'; CTX.fillText("PAUSED", CANVAS.width/2, CANVAS.height/2); } } if (isPaused || isAnimating) return; if ((e.code === 'KeyA' || e.code === 'ArrowLeft') && !(keyState.KeyA || keyState.ArrowLeft)) { if (e.code === 'KeyA') keyState.KeyA = true; if (e.code === 'ArrowLeft') keyState.ArrowLeft = true; moveTimers.KeyA = -DAS_DELAY; playerMove(-1); draw(); } if ((e.code === 'KeyD' || e.code === 'ArrowRight') && !(keyState.KeyD || keyState.ArrowRight)) { if (e.code === 'KeyD') keyState.KeyD = true; if (e.code === 'ArrowRight') keyState.ArrowRight = true; moveTimers.KeyD = -DAS_DELAY; playerMove(1); draw(); } switch(e.code) { case 'KeyS': case 'ArrowDown': playerDrop(); draw(); break; case 'KeyW': case 'ArrowUp': playerRotate(1); draw(); break; case 'Space': playerHardDrop(); draw(); break; case 'KeyR': playerHold(); draw(); break; } });
        document.addEventListener('keyup', e => { if (e.code === 'KeyA') keyState.KeyA = false; if (e.code === 'KeyD') keyState.KeyD = false; if (e.code === 'ArrowLeft') keyState.ArrowLeft = false; if (e.code === 'ArrowRight') keyState.ArrowRight = false; });
        window.addEventListener('keydown', function(e) { if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1 && e.target.tagName !== 'INPUT') { e.preventDefault(); } }, false);

        document.getElementById('resumeBtn').addEventListener('click', toggleMenu);
        document.getElementById('disconnectBtn').addEventListener('click', disconnectGame);
        document.getElementById('startBtn').addEventListener('click', () => { isMultiplayer = false; document.getElementById('opponentContainer').style.display = 'none'; startGame(); });
        document.getElementById('optionsBtn').addEventListener('click', () => showMenu('optionsMenu'));
        document.getElementById('optionsBackBtn').addEventListener('click', () => showMenu('overlay'));
        document.getElementById('musicToggleBtn').addEventListener('click', toggleMusic);
        document.getElementById('crtToggleBtn').addEventListener('click', toggleCRT);
        document.getElementById('fsToggleBtn').addEventListener('click', toggleFullscreen);
        document.getElementById('volumeSlider').addEventListener('input', (e) => { masterVolume = e.target.value / 100; document.getElementById('volumeValue').innerText = e.target.value + "%"; });
        document.getElementById('mpBtn').addEventListener('click', () => { showMenu('mpMenu'); document.getElementById('mpOptions').style.display = 'block'; document.getElementById('mpLobby').style.display = 'none'; document.getElementById('mpStatus').innerText = ""; });
        document.getElementById('aboutBtn').addEventListener('click', () => { showMenu('aboutMenu'); document.getElementById('aboutAppId').innerText = appId; if (currentUser) document.getElementById('aboutUserId').innerText = currentUser.uid; });
        document.getElementById('aboutBackBtn').addEventListener('click', () => showMenu('overlay'));
        document.getElementById('backBtn').addEventListener('click', () => showMenu('overlay'));
        document.getElementById('hostBtn').addEventListener('click', hostGame);
        document.getElementById('joinBtn').addEventListener('click', joinGame);
        document.getElementById('cancelHostBtn').addEventListener('click', () => { if (gameSessionUnsubscribe) gameSessionUnsubscribe(); document.getElementById('mpLobby').style.display = 'none'; document.getElementById('mpOptions').style.display = 'block'; });
        document.getElementById('readyBtn').addEventListener('click', toggleReady);
        document.getElementById('startGameBtn').addEventListener('click', tryStartGame);
        document.getElementById('chatSendBtn').addEventListener('click', sendMessage);
        document.getElementById('chatInput').addEventListener('keydown', (e) => { e.stopPropagation(); if (e.key === 'Enter') sendMessage(); });
        document.getElementById('chatInput').addEventListener('keyup', (e) => e.stopPropagation());

        function resizeGame() { const layout = document.querySelector('.main-layout'); if (!layout) return; const padding = 40; const availableWidth = window.innerWidth - padding; const availableHeight = window.innerHeight - padding; let baseWidth = 800; if (isMultiplayer) baseWidth = 1600; const baseHeight = 1100; const scaleX = availableWidth / baseWidth; const scaleY = availableHeight / baseHeight; const scale = Math.min(scaleX, scaleY); layout.style.transform = `translate(-50%, -50%) scale(${scale})`; }
        window.addEventListener('resize', resizeGame); resizeGame(); setTimeout(resizeGame, 500);
    </script>
</body>
</html>